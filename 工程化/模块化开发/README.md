##### 为什么要使用模块化

- 解决命名冲突
- 提供复用性
- 提高代码可维护性



##### 介绍模块化发展历程







## CommonJS, AMD, CMD，es6规范

- 对 CommonJS 的实现 , 有 node 的模块系统 ;
- 对 AMD 的实现有require.js ;
- 而 CMD, 是在sea.js的实现中提出来的 `(但是在Google和Stack Overflow, 这个概念很少被提到, 一般出现在国内)`。



- CommonJS规范， 模块加载是同步的
  `对node来说，模块存放在本地硬盘，同步加载，等待时间就是硬盘的读取时间，这个时间非常短;`
- AMD、CMD 规范，模块加载是异步的
  `目的, 是为了适应浏览器环境，加载的时间取决于网络的好坏，可能要等很长时间;`



#### 总结

AMD和CMD最大的区别是: 对依赖模块的执行时机处理不同`(注意不是加载的时机)`

很多人说, requireJS是异步加载模块，SeaJS是同步加载模块，这么说实际上是不准确的 ;
二者加载模块都是异步的 ;

只不过**AMD依赖前置**，可以方便知道依赖了哪些模块，然后马上加载 , 在加载完成后, 就会执行该模块;
而**CMD推崇就近依赖**，把模块变为字符串解析一遍, 找到依赖了哪些模块, 在加载模块完成后, 不立刻执行, 而是等到`require`后再执行;

上面只说了异步相关的概念, 其实 require.js / sea.js , 最重要的还是**模块化**。
模块化降低耦合，依赖清晰，让调试, 加功能, 任务分配和交接都更方便。





**CommonJS规范--**-是通过**module.exports定**义的

**ES6特性，模块化**---**export/import对模块进行导出导入的**



es6静态编译





#### CommonJS

NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。[node.js](http://nodejs.org/)将javascript语言用于服务器端编程。**require 是同步的**

#### AMD

基于commonJS规范的nodeJS出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，**使得CommonJS规范不适用于浏览器环境**。

require 是同步的，这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。

AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

#### CMD

CMD 推崇依赖就近，AMD 推崇依赖前置。

#### ES6 模块化

ES6 模块化采用静态编译，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。

treeshaking等的应用





对于 `CommonJS` 和 ES6 中的模块化的两者区别是：

- 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响。
- 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化











