### 什么是原型

一个js对象，在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。继承意味着复制，而这里只是两个对象的关联，委托的说法准确些。

访问对象a的属性，会先查找a自身有否这个属性，没有，则会找原型上是否有这个属性，原型也是对象，也会有自己的原型。访问属性的时候会先查找自身属性，没有则沿着这条原型链去查找。当然，原型是一个被关联的对象实例，可以同时被多个对象关联，原型则在多个对象中共享，原型属性值被修改，会影响多个对象。



### 屏蔽

1. 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性，并且没有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。 

2. 如果在 [[Prototype]] 链上层存在 foo，但是它被标记为只读（writable:false），那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 

3. 如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter，那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这 个 setter。

   

   

   

**构造函数和实例原型**（Person和 Person.prototype）：构造函数的prototype属性指向实例原型。

**实例和实例原型**（person 和 Person.prototype ）：实例的__proto__指向实例原型。

**原型与构造函数**：每个原型都有一个 constructor 属性指向关联的构造函数。当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取

**原型的原型**：原型也是一个对象，也有自己的原型，原型对象就是通过 Object 构造函数生成的，Object.prototype.`__proto__`指向null

**原型链**：当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。

![111](../../../_assets/image/prototype5.png)

