> AMD，CMD，CommonJS，ES6 模块



## require.js

```js
// main.js
require(['./add', './square'], function(addModule, squareModule) {
    console.log(addModule.add(1, 1))
    console.log(squareModule.square(3))
});
```

```js
// square.js
define(['./multiply'], function(multiplyModule) {
    console.log('加载了 square 模块')
    return {　　　　　　
        square: function(num) {
            return multiplyModule.multiply(num, num)
        }
    };
});
```

`requirejs` 为全局添加了 `define` 函数，你只要按照这种约定的方式书写这个模块即可。

`require.js` 会自动分析依赖关系，将需要加载的模块正确加载。



## AMD

**AMD 是 RequireJS 在推广过程中对模块定义的规范化产出**

你去看 [AMD 规范](https://github.com/amdjs/amdjs-api/wiki/AMD-(中文版)) 的内容，其主要内容就是定义了 define 函数该如何书写，只要你按照这个规范书写模块和依赖，require.js 就能正确的进行解析。



## sea.js

```js
// main.js
define(function(require, exports, module) {
    var addModule = require('./add');
    console.log(addModule.add(1, 1))

    var squareModule = require('./square');
    console.log(squareModule.square(3))
});
```

```js
// square.js
define(function(require, exports, module) {
    console.log('加载了 square 模块')
    var multiplyModule = require('./multiply');
    module.exports = {　　　　　　
        square: function(num) {
            return multiplyModule.multiply(num, num)
        }
    };
});
```

> seajs是怎么加载的？require异步？





## CMD

与 AMD 一样，CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出。

你去看 [CMD 规范](https://github.com/seajs/seajs/issues/242)的内容，主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析。



## AMD 与 CMD 的区别

1. CMD 推崇**依赖就近**，AMD 推崇**依赖前置**（依赖必须一开始就写好）
2. 对于依赖的模块，AMD 是**提前执行**，CMD 是**延迟执行**。AMD 是将需要使用的模块先加载完再执行代码，而 CMD 是在 require 的时候才去加载模块文件，加载完再接着执行。



## CommonJS

AMD 和 CMD 都是用于浏览器端的模块规范，而在服务器端比如 node，采用的则是 CommonJS 规范。

```js
// main.js
var add = require('./add.js');
console.log(add.add(1, 1))

var square = require('./square.js');
console.log(square.square(3));
```

```js
// square.js
console.log('加载了 square 模块')

var multiply = require('./multiply.js');

var square = function(num) {　
    return multiply.multiply(num, num);
};

module.exports.square = square;
```



## CommonJS 与 AMD

- CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。
- AMD规范则是非同步加载模块，允许指定回调函数。
- 由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。  
- 但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。





## 介绍模块化发展历程

#### 什么是模块化？

模块就是把一些代码聚合在一起，组成一个“功能”。

好的模块，是高度独立的，它可以被随时加入或者移除，而不会损害系统。

**好处**：

- 避免命名冲突(减少命名空间污染)
- 更好的分离, 按需加载
- 更高复用性
- 高可维护性



#### 如何实现

##### 1.匿名函数立即执行

##### 2.把全局函数注入到匿名函数（jQuery）



上面这些方法都有一个共同点：**使用一个特定的全局模块名来把一些私有变量和方法包起来，然后通过闭包来创建一个私有的命名空间。**

这样也就有一个共同的缺点，就是无法管理不同模块之间的依赖关系。比如说，如果我们的项目用到了 Backbone.js 库，所以我们会把 Backbone.js 的代码引入到项目中。

不过，由于 Backbone 依赖 Underscore.js，所以 Backbone.js 的代码需要放在 Underscore.js 之后。

**当依赖的库多起来了，记住这些库应该以什么样的顺序去加载就是一件很头疼的事情了。**

另一个明显的缺点是，依次引入这些模块仍然没有解决命名空间冲突的问题。比如 jQuery 和其他库可能都使用了 `$` 来作为暴露的名字，或者我们引用了同一个模块的两个不同版本怎么办？

幸运的是，我们有两个已经得到广泛支持的解决方案：**CommonJS 和 AMD**。



