

**引擎**：从头到尾负责整个 JavaScript 程序的编译及执行过程。

**编译器**：负责语法分析及代码生成等脏活累活。

**作用域**：根据名称查找变量的一套规则。负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

> 自己说：作用域用来确定当前执行的代码对这些标识符的访问权限。是根据名称查找变量的一套规则。



## 编译器

### 编译原理

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。

- 分词/词法分析（Tokenizing/Lexing） => ['var', 'a', '=', '2', ' ;']

  这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。

- 解析/语法分析（Parsing） => AST

  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。 var a = 2; 的抽象语法树中可能会有一个叫作VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子 节点。

- 代码生成

  将 AST 转换为可执行代码的过程称被称为代码生成。



##### 实例：`var a = 2;`

1.遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。

2.接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！



> 疑问

变量声明是在语法分析阶段即生成AST时候做的吧？



## 作用域

作用域分为**词法作用域**和**动态作用域**。

js是词法作用域，即写代码时将变量和块作用域写在哪里决定的。



### 作用域链

嵌套作用域中。引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。



### 遮蔽效应

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性。



### 查询

引擎查找变量a的方式: LHS查询 和 RHS查询。含义是“赋值操作的左侧或右侧”。在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。

RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其**赋值**。

```js
// RHS查询a
console.log(a)
// LHS, 实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。
a = 2
```

```js
function foo(a) { 
    // var a = 2 LHS
    console.log( a ); // 2 RHS 
}
foo( 2 ); // foo进行RHS
```

LHS：为赋值操作找到一个目标
RHS：得到某某的值

#### 异常

1. 未声明变量

   LHS：
   非严格模式，在全局作用域创建变量；
   严格模式，ReferenceError；

   RHS：ReferenceError；

2. RHS变量进行不合理操作，TypeError



### 欺骗词法

- 方式

  - eval

    eval：对词法作用域进行修改

    严格模式下，eval有自己的词法作用域，其中的声明无法影响当前的作用域。
    setTimeout、setInterval第一个参数是字符串时，类似。

  - with

    with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。

    若给obj不存在的属性赋值，容易泄漏到全局作用域上。
    
    ```js
    function foo(obj) {
    	with (obj) { 
            a = 2; 
        } 
    }
    var o1 = { a: 3 };
    var o2 = { b: 3 };
    foo( o1 ); 
    // o1中原本就有属性a
    console.log( o1.a ); // 2 foo( o2 ); 
    // o2中原本没有属性a
    console.log( o2.a ); // undefined 
    console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
    ```
    
    

- 性能

  eval(..) 和 with 会在运行时修改或创建新的作用域。
  JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
  但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。
  最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。



### 函数作用域和块作用域

- 函数作用域

  属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。

- 块作用域

  例子： with, try/catch, let, const

  - let, const

     只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块。

    ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。

    > for循环

    ```js
    {
      let j;
      for (j=0; j<10; j++) {
        let i = j; // 每个迭代重新绑定！ 
        console.log( i ); 
      }
    }
    ```

    

### 提升

> 现象

var a = 2;
JavaScript 实际上会将其看成两个声明：var a; 和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。



- 函数优先（于变量提升执行）

  执行过程：

  1. 找到所有用 function 声明的变量，在环境中「创建」这些变量。
  2. 将这些变量「初始化」并「赋值」为 相应的fn。

- var vs let

  - var

    执行fn的过程(不完全):

    1. 进入 fn，为 fn 创建一个环境。
    2. 找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。
    3. 将这些变量「初始化」为 undefined。
    4. 开始执行代码。

  - let

    `{ let x =1 }` 里的过程：

    1. 找到所有用 let 声明的变量，在环境中「创建」这些变量。

    2. 开始执行代码（注意现在还没有初始化）。

    3. 执行 x = 1，将 x 「初始化」为 1。

       这并不是一次赋值，如果代码是 let x，就将 x 初始化为undefined。

  #### 暂时性死区
  
  let 的「创建」过程被提升了，但是初始化没有提升。初始化前访问变量，会报ReferenceError。

