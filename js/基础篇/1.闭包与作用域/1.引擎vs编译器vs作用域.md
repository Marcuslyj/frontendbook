**引擎**：从头到尾负责整个 JavaScript 程序的编译及执行过程。

**编译器**：负责语法分析及代码生成等脏活累活。

**作用域**：根据名称查找变量的一套规则。负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

------



## 编译器

#### 编译过程

1.分词/词法分析：将由字符组成的字符串分解成（对编程语言来说）有意义的代码块。

2.解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树（AST）。

3.代码生成：将 AST 转换为可执行代码的过程称被称为代码生成。



##### 实例：`var a = 2;`

1.遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。

2.接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异 常！



> 疑问

变量声明是在语法分析阶段即生成AST时候做的吧？



## 作用域

作用域分为**词法作用域**和**动态作用域**。

js是词法作用域，即写代码时将变量和块作用域写在哪里决定的。



### 作用域链

嵌套作用域中。引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。



### 查询

LHS：为赋值操作找到一个目标
RHS：得到某某的值

#### 异常

1. 未声明变量

   LHS：
   非严格模式，在全局作用域创建变量；
   严格模式，ReferenceError；

   RHS：ReferenceError；

2. RHS变量进行不合理操作，TypeError



### 欺骗词法

- 方式

  - eval

    eval：对词法作用域进行修改

    严格模式下，eval有自己的词法作用域，其中的声明无法影响当前的作用域。
    setTimeout、setInterval第一个参数是字符串时，类似。

  - with

    with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。

    若给obj不存在的属性赋值，容易泄漏到全局作用域上。

- 性能

  eval(..) 和 with 会在运行时修改或创建新的作用域。
  JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
  但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。
  最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。



### 函数作用域和块作用域

- 函数作用域

  属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。

- 块作用域

  例子： with, try/catch, let, const

  - let, const

     只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块。

    ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。

    > for循环

    ```js
    {
      let j;
      for (j=0; j<10; j++) {
        let i = j; // 每个迭代重新绑定！ 
        console.log( i ); 
      }
    }
    ```

    

### 提升

> 现象

var a = 2;
JavaScript 实际上会将其看成两个声明：var a; 和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。



- 函数优先（于变量提升执行）

  执行过程：

  1. 找到所有用 function 声明的变量，在环境中「创建」这些变量。
  2. 将这些变量「初始化」并「赋值」为 相应的fn。

- var vs let

  - var

    执行fn的过程(不完全):

    1. 进入 fn，为 fn 创建一个环境。
    2. 找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。
    3. 将这些变量「初始化」为 undefined。
    4. 开始执行代码。

  - let

    `{ let x =1 }` 里的过程：

    1. 找到所有用 let 声明的变量，在环境中「创建」这些变量。

    2. 开始执行代码（注意现在还没有初始化）。

    3. 执行 x = 1，将 x 「初始化」为 1。

       这并不是一次赋值，如果代码是 let x，就将 x 初始化为undefined。

    let 的「创建」过程被提升了，但是初始化没有提升。初始化前访问变量，会报ReferenceError，

