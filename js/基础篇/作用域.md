### 编译原理

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。

- 分词/词法分析（Tokenizing/Lexing） => ['var', 'a', '=', '2', ' ;']

  这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。

- 解析/语法分析（Parsing） => AST

  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。 var a = 2; 的抽象语法树中可能会有一个叫作VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子 节点。

- 代码生成

  将 AST 转换为可执行代码的过程称被称为代码生成。



### 引擎、编译器、作用域

- 引擎

  从头到尾负责整个 JavaScript 程序的编译及执行过程。

- 编译器

  引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。

- 作用域

  引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

  > 自己说：作用域用来确定当前执行的代码对这些标识符的访问权限。是根据名称查找变量的一套规则。

  

### var a = 2的编译执行过程

变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。

1. 编译器词法分析、语法分析。
2. 编译器代码生成时，遇到var a， 会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。 为引擎生成运行时所需要的代码。
3. 引擎运行时，询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。找不到会抛出异常。



### LHS RHS

引擎查找变量a的方式: LHS查询 和 RHS查询。含义是“赋值操作的左侧或右侧”。在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。 

> 自己说：
>
> LHS，给谁赋值
>
> RHS，拿什么值来赋值

RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其**赋值**。

```js
// RHS查询a
console.log(a)
// LHS, 实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。
a = 2
```

```js
function foo(a) { 
    // var a = 2 LHS
    console.log( a ); // 2 RHS 
}
foo( 2 ); // foo进行RHS
```

#### 异常

非严格模式下，LHS查询，在顶层还是查询不到，会在顶层声明一个。严格模式会报错。

RHS的时候无法找到该变量的值，则会抛出ReferenceError异常



### 作用域嵌套（作用域链）

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。



### 词法作用域

上面已经介绍过，作用域用来确定当前执行的代码对这些标识符的访问权限。是根据名称查找变量的一套规则。

作用域有两种工作模型：

- 词法作用域
- 动态作用域

#### 词法作用域

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

#### 遮蔽效应

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性。

#### 欺骗词法

**欺骗词法作用域会导致性能下降。** 

##### eval

接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。

在**严格模式**的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

##### with

```js
function foo(obj) {
	with (obj) { 
        a = 2; 
    } 
}
var o1 = { a: 3 };
var o2 = { b: 3 };
foo( o1 ); 
// o1中原本就有属性a
console.log( o1.a ); // 2 foo( o2 ); 
// o2中原本没有属性a
console.log( o2.a ); // undefined 
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```

其实就是LHS查询

##### 性能

eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 

但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。

最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。



### 函数作用域和块作用域

#### 函数作用域

```js
for(var i=0;i<10;i++){

}
console.log(i) // 10 污染
```



#### 块作用域

##### with

#### try/catch

```js
try {
	undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
	console.log( err ); // 能够正常执行！
}
console.log( err ); // ReferenceError: err not found
```

#### let const

```js
for (let i=0; i<10; i++) {
	console.log( i );
}
// 即
{
	let j;
	for (j=0; j<10; j++) {
		let i = j; // 每个迭代重新绑定！
		console.log( i );
	}
}
```



