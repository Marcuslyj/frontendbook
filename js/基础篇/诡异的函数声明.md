浏览器版本不同，表现不一致

先看代码

```js
function f() { console.log('I am outside!') }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!') }
  }
  f()
}())
```

上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部。

严格模式下(es6)，会得到“I am outside!”

新版浏览器，非严格模式下，'undefined'，报错



如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

- 允许在块级作用域内声明函数。
- 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。



code

```js
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f()
}())
// Uncaught TypeError: f is not a function
```

实际运行

```js
// 浏览器的 ES6 环境
function f() { console.log('I am outside!') }
(function () {
  var f = undefined
  if (false) {
    function f() { console.log('I am inside!') }
  }

  f()
}())
// Uncaught TypeError: f is not a function
```





另一个实例

```js
var a;
if(true){
    a = 5;
    function a() {}
    a = 0;
    console.log(a)
}
console.log(a)
```

谷歌浏览器结果： 0  5

StackOverflow网友解答：

The following happens:

(1) There exist two variable declarations `a`, one inside the block and one outside of it.

(2) The function declaration gets hoisted, and bound to the inner blocks variable.

(3) `a = 5` is reached, which overrides the block variable.

(4) the function declaration is reached, and the block variable is copied to the outer variable. Both are 5 now.

(5) `a = 0` is reached, which overrides the block variable. The outer variable is not affected by this.

```js
 var a¹;
 if (true) {
   function a²() {} // hoisted
   a² = 5;
   a¹ = a²; // at the location of the declaration, the variable leaves the block      
   a² = 0;
  console.log(a²)
}
console.log(a¹);
```

This is actually not really part of the specification, it is part of the [web legacy conpability semantics](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics), so *don't declare functions inside blocks* and *don't rely on this code to behave in this way*.

This is also explained [here](https://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)



##### 变异1

```js
var a;
if(true){
    a = 5;
    function a() {}
    a = 8;
    function a() {}
    a = 0;
    console.log(a)
}
console.log(a)
```

chrome：

非严格模式： 0 8

严格模式：0 undefined



##### 变异2

```js
var a;
{
    function a(){}
    a = 0
    console.log(a)
}
console.log(a)
```

chrome： 

非严格模式：0  function a(){}

严格模式： 0 undefined























































