![网络编程懒人入门(../_assets/image/120246jsjzwjq6l6i9zi5155.png)：快速理解TCP协议一篇就够_1.png](http://www.52im.net/data/attachment/forum/201710/12/120246jsjzwjq6l6i9zi51.png)

最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。



但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。

路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入多根网线。路由器内部有一张路由表，规定了 A 段 IP 地址走出口一，B 段地址走出口二，......通过这套"指路牌"，实现了数据包的转发。



IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。



#### TCP 数据包的编号（SEQ）

发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。

第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。



#### TCP 数据包的组装

收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。



#### 数据包的遗失处理

前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。

如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。





#### TCP握手挥手

![网络编程懒人入门(../_assets/image/110528h9iiyaqrryaijd1gi.jpg)：快速理解TCP和UDP的差异_1915184-43e91a9185faa031.jpg](http://www.52im.net/data/attachment/forum/201710/27/110528h9iiyaqrryaijdgi.jpg)



> TCP建立连接和初始化目标

- 1）初始化资源；
- 2）告诉对方我的序列号。

所以三次握手的次序是这样子的：

- 1）client端首先发送一个SYN包告诉Server端我的初始序列号是X；
- 2）Server端收到SYN包后回复给client一个ACK确认包，告诉client说我收到了；
- 3）接着Server端也需要告诉client端自己的初始序列号，于是Server也发送一个SYN包告诉client我的初始序列号是Y；
- 4）Client收到后，回复Server一个ACK确认包说我知道了。

其中的 2 、3 步骤可以简化为一步，也就是说将 ACK 确认包和 SYN 序列化包一同发送给 Client 端。到此我们就比较简单的解释了 TCP 建立连接的“三次握手”。



握手状态：SYN_SENT、SYN_RCVD、ESTABLISHED、ESTABLISHED



> 挥手

两边都要单独发起关闭



挥手状态：FIN_WAIT1、CLOSE_WAIT、FIN_WAIT2、LAST_ACK、TIME_WAIT



##### 为什么要TIME_WAIT（2个MS）

MSL就是maximium segment lifetime——最长报文寿命

1. 重传最后一个ACK报文，确保服务端收到
2. 该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。































