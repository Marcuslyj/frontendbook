##### 复杂度：大 O 表示法指出了最糟情况下的运行时间

下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。
 O(log n)，也叫对数时间，这样的算法包括二分查找。
 O(n)，也叫线性时间，这样的算法包括简单查找。
 O(n * log n)，这样的算法包括快速排序——一种速度较快的排序算法。
 O(n^2)，这样的算法包括选择排序——一种速度较慢的排序算法。
 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

![1567652354204](../../_assets/image/1567652354204.png)



## 二分查找

- 有序列表才能二分查找
- 时间复杂度 log2N，比如8个元素，最多只需要查找3次就能找到，2^3 = 8



## 选择排序

- 遍历n次，每次遍历最大值，添加到新数组
- 时间复杂度：O(n^2)

![1567666698998](../../_assets/image/1567666698998.png)



![1567666792182](../../_assets/image/1567666792182.png)





## 递归

 递归指的是调用自己的函数。
 每个递归函数都有两个条件：基线条件和递归条件。
 调用栈可能很长，这将占用大量的内存。

存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况
下，你有两种选择。
 重新编写代码，转而使用循环。
 使用尾递归。另外，并非所有的语言都支持尾递归。



## 快速排序

涉及D&C，使用D&C（分而治之，divide and conquer）解决问题的过程包括两个步骤。
(1) 找出基线条件，这种条件必须尽可能简单。
(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。



快排：

- 时间复杂度，最糟糕情况（有序数组）是O(n^2)，平均O(nlogn)。
- 逻辑：递归执行，取数组第一个元素最为基准值，遍历数组，比基准值小或者打的放在基准值两边，进行分组。即，[left]+base+[right]，递归对分组进行分组排序合并。

层数为O(log n)（用技术术语说，调用栈的高度为O(log n)），而每层需要的时间为O(n)，因为要遍历分组。因此整个算法需要的时间为O(n) * O(log n) = O(n log n)。这就是最佳情况。



快排自实现：

```js
            function quicksort(arr) {
                // 只有0个或1个元素，直接返回，不需要排序
                if (arr.length < 2) {
                    return arr
                }

                let base = [arr[0]];
                let left = [];
                let right = [];
                for (let i = 1; i < arr.length; i++) {
                    if (arr[i] > arr[0]) {
                        right.push(arr[i])
                    } else if (arr[i] < arr[0]) {
                        left.push(arr[i])
                    } else {
                        base.push(arr[i])
                    }
                }

                return quicksort(left).concat(base).concat(quicksort(right))
            }
```





## 广度优先搜索

- 广度优先搜索用于在非加权图中查找最短路径。



##### 图是什么

图模拟一组连接。图用于模拟不同的东西是如何相连的。

例如，假设你与朋友玩牌，并要模拟谁欠谁钱，可像下面这样指出Alex欠Rama钱。图由节点（node）和边（edge）组成。

![1567734165868](../../_assets/image/1567734165868.png)

有向图 VS 无向图

无向图：没有箭头，直接相邻的节点互为邻居。

有向图：有箭头，其中的关系是单向的。



##### 运行时间

你将沿每条边前行（记住，边是从一个人到另一个人的箭头或连接），因此运行时间至少为O(边数)。

你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数。





## 狄克斯特拉算法

- 狄克斯特拉算法用于在加权图中查找最短路径。
- 仅当权重为正时狄克斯特拉算法才管用。
- 如果图中包含负权边，请使用贝尔曼福德算法。



带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。

![1567736242905](../../_assets/image/1567736242905.png)

要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。图还可能有环，而环类似右面这样。





## 贪婪算法

贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。

用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。































