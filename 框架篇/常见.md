##### 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？()

##### React 中 setState 什么时候是同步的，什么时候是异步的？

##### React setState 笔试题，下面的代码输出什么？

> ```js
> class Example extends React.Component {
>   constructor() {
>     super();
>     this.state = {
>       val: 0
>     };
>   }
>   
>   componentDidMount() {
>     this.setState({val: this.state.val + 1});
>     console.log(this.state.val);    // 第 1 次 log
> 
>     this.setState({val: this.state.val + 1});
>     console.log(this.state.val);    // 第 2 次 log
> 
>     setTimeout(() => {
>       this.setState({val: this.state.val + 1});
>       console.log(this.state.val);  // 第 3 次 log
> 
>       this.setState({val: this.state.val + 1});
>       console.log(this.state.val);  // 第 4 次 log
>     }, 0);
>   }
> 
>   render() {
>     return null;
>   }
> };
> ```



##### 聊聊 Redux 和 Vuex 的设计思想

### 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的

![img](../_assets/image/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744b665463677931673168316a6b766465396a33306b3030616e7133322e6a7067)

VM 主要做了两件微小的事情：

- **从 M 到 V 的映射（Data Binding）**，这样可以大量节省你人肉来 update View 的代码
- **从 V 到 M 的事件监听（DOM Listeners）**，这样你的 Model 会随着 View 触发事件而改变







## Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。





# 在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的。

所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。（这个props可能在多个子组件使用到，导致子组件相互影响）



在组件 `initProps` 方法的时候，会对props进行defineReactive操作，传入的第四个参数是自定义的set函数，该函数会在触发props的set方法时执行，当props修改了，就会运行这里传入的第四个参数，然后进行判断，如果不是root根组件，并且不是更新子组件，那么说明更新的是props，所以会警告







## 双向绑定和 vuex 是否冲突

vuex数据直接使用v-model，修改不是在 mutation 函数中执行，严格模式中会抛错误。

方案1：input事件，v-model只是语法糖

```html
<input :value="message" @input="updateMessage">
```

```js
computed: {
  ...mapState({
    message: state => state.obj.message
  })
},
methods: {
  updateMessage (e) {
    this.$store.commit('updateMessage', e.target.value)
  }
}
```

  方案2：计算属性

```html
<input v-model="message">
```

```js
computed: {
  message: {
    get () {
      return this.$store.state.obj.message
    },
    set (value) {
      this.$store.commit('updateMessage', value)
    }
  }
}
```

  





















##### 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？

##### 在 Vue 中，子组件为何不可以修改父组件传递的 Prop

## Vue 的响应式原理中 Object.defineProperty 有什么缺陷？







##### redux 为什么要把 reducer 设计成纯函数

##### Vue 的父组件和子组件生命周期钩子执行顺序是什么

##### react-router 里的 `<Link>`标签和 `<a>` 标签有什么区别

##### vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？

##### React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？

##### vue 渲染大量数据时应该怎么优化？

##### vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？

##### vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法

##### vue项目首页白屏时间较长



# Vue 中的 computed 是如何实现的

实质是一个惰性的watcher，在取值操作时根据自身标记 dirty属性返回上一次计算结果/重新计算值在创建时就进行一次取值操作，收集依赖变动的对象/属性(将自身压入dep中)在依赖的对象/属性变动时，仅将自身标记dirty致为true



渲染watcher订阅了computed watcher的变化，计算属性中以来的响应式数据发生变化时，computed watcher会标记为dirty为true，重新计算，否则直接返回this.value（上次的计算值）





# nextTick 的原理

> 现象

定义了一个响应式的文本数据，显示在页面上。当修改这个数据后，直接获取dom节点的该文本数据，发现数据并没有更新。当在nexttick里边获取就整正常获取。

> 原因

dom更新和我们定义的获取文本的回调方法都在nexttick事件队列里边，依次执行。保证了dom更新执行在前

> 实现

修改响应式数据，在vue的双向绑定-响应式系统中，会经过 “setter -> Dep -> Watcher -> patch -> 视图” 这个流水线。

Vue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象其实会被 push 进一个队列 queue 中，在下一个 **tick** 的时候将这个队列 queue 全部拿出来 run一遍。

*数据（假设num：0）循环递增一百次，只会更新一次。*

Vue在修改数据的时候，不会立马就去修改数据。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。

nextTick函数其实做了两件事情，

一是生成一个timerFunc，把回调作为microTask或macroTask参与到事件循环中来。

二是把回调函数放入一个callbacks队列，等待适当的时机执行

**flushCallbacks** 就是for循环执行callbacks，pending = false

if(!pending),执行macroTimerFunc或microTimerFunc。这两个方法其实就是把flushCallbacks放进promise或settimeout等去执行，参与到事件循环







































